# [2024_06_16]

### 공부내용 : PRG, Singleton, Strategy Pattern

## [PRG 패턴]

<img width="516" alt="prg" src="https://github.com/GollllDong/TIL/assets/109501612/72a4ecbb-d637-4500-baf3-8d6cae9a15bc">


1. 최초에 브라우저에서 서버로 값을 넘겨준다. 
    
    (이전에 사용자가 입력한 데이터들은 GET, 입력한 데이터들을 POST방식으로 넘겨줌)
    
2. 브라우저의 값을 POST방식으로 암호화해서 다른주소로 Redirect하도록 응답
3. 브라우저에 이동할 주소를 받음
4. 브라우저에서 서버에 POST방식으로 넣어둔 값을 GET방식으로 호출
5. 서버에서 GET방식으로 처리해서 브라우저에게 전달
    
    (새로 고침을 해도 이전에 입력한 데이터를 다시 제출하지 않게 되기 때문에 중복 제출을 막는다.)

## [싱글톤 패턴]

enum으로  객체를 하나만 생성해서 해당 객체를 공유하면서 사용하는 간단한 패턴

WAS는 동적인 데이터를 처리하는데 request, response 객체는 클라이언트마다 값이 매번 다르기 때문에 요청이 들어올때마다 새로 생성하도록 한다.

하지만 서블릿은 클라이언트의 요청이 들어올때마다 객체를 생성하는 것은 비효율적이기 때문에

공통적으로 사용할 객체를 하나 만들어서 **서블릿이 실행되는 시점에 서블릿 객체를 미리 만들어두고 재활용한다.**

서블릿 컨테이너가 종료될 때 서블릿도 같이 종료되고 JSP도 서블릿으로 변환되어 사용된다.

제일 중요한 특징은 **동시 요청을 위한 멀티 쓰레드 처리를 지원**한다.

## [전략 패턴(Strategy Pattern)]

객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여, 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략만 바꿔주면서 유연하게 수정해주는 방법.

쉽게 말해서 객체가 할 수 있는 행위들 **각각을 전략**으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 **전략을 바꾸는 것만으로 행위의 수정이 가능**하도록 만든 패턴이다.

컴퓨터와 맥북 대한 클래스가 존재할때

```java
public interface Conversion {
	public void sound();
}

public class Computer implements Conversion {
	public void sound(){
		System.out.println("빠바방~~");
	}
}

public class MacBook implements Conversion {
	public void change(){
		System.out.println("우우우우움~~~");
	}
}
```

만약 컴퓨터를 쓰다가 맥북소리를 사용하는 컴퓨터가 생겼을때 change()메서드를 

MacBook클래스의 change()메서드를 사용하면 되지만 이건 **SOLID의 원칙 중 하나인 OCP에 위배**된다.

OCP에 의하면 기존의 change()를 수정하지 않으면서 행위가 수정되야 하지만 MacBook의 change()메서드를 직접 수정했다.

또한 여러개의 노트북, 컴퓨터, 아이패드 등에서 change()메서드를 사용하게 된다면 메서드의 중복이나 각 클래스마다 해당 메서드를 일일이 수정해야 하기 때문에 **전략 패턴을 사용**한다.