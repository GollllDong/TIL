## **Proxy 개념 정리**

- *즉시 로딩(EAGER)**과 **지연 로딩(LAZY)**는 JPA에서 연관 관계를 처리하는 두 가지 방식
    - **즉시 로딩(EAGER)**:
        - **@OneToOne**과 **@ManyToOne관계에서** 기본값이다.
        - **엔티티를 조회하는 순간** 연관된 모든 데이터를 한꺼번에 가져온다.
        - 장점: 한 번의 쿼리로 관련 데이터를 모두 가져오기 때문에 **즉시 처리**가 가능하다.
        - 단점: **불필요한 데이터**까지 한 번에 조회되면서 **성능 저하**나 **DB 부하**가 발생할 수 있다.
    - **지연 로딩(LAZY)**:
        - **@OneToMany**와 **@ManyToMany**에서 기본값이다.
        - **엔티티를 실제로 사용할 때**, 즉 **메서드나 변수에 접근할 때** 쿼리가 실행되어 데이터를 조회한다.
        - 장점: **필요한 시점에만 데이터**를 조회하므로 **불필요한 리소스 낭비**가 없다.
        - 단점: **객체를 사용할 때마다 추가적인 쿼리**가 발생할 수 있으므로 **성능 문제가 발생**할 수 있다.
- **프록시 객체**:
    - **지연 로딩**을 사용하는 경우, 엔티티를 **프록시 객체**로 대체하여 데이터를 **사용하는 시점까지 지연**시킨다.
    - **프록시 객체**는 실제 객체를 상속받아 만들어졌기 때문에 구분이 어려우며, **데이터에 접근하는 순간** 프록시가 **원본 객체로 대체**된다.
    - 단점: 프록시 객체가 **초기화될 때마다** 추가 쿼리가 발생할 수 있어, 성능에 영향을 줄 수 있다.
- **컬렉션 래퍼**:
    - **지연 로딩**을 사용하는 컬렉션(`@OneToMany`, `@ManyToMany`)은 **컬렉션 래퍼**라는 프록시 객체로 처리된다.
    - 컬렉션 자체에 접근할 때는 초기화되지 않으며, **컬렉션 내부의 데이터에 접근하는 순간** 쿼리가 실행된다.
    - 예: `member.getOrders()`는 초기화되지 않지만, `member.getOrders().get(0)`처럼 **컬렉션 안의 값을 접근하는 순간** 초기화가 발생한다.
- **즉시 로딩과 외부 조인**:
    - **즉시 로딩**은 **내부 조인**보다 **외부 조인**을 사용하는 것이 일반적으로 더 안전하다.
    - 특히 다대일(1) 관계에서는 내부 조인을 사용하면, 연결된 테이블의 값이 존재하지 않을 경우 데이터를 가져오지 못할 위험이 있다.
- **지연 로딩을 우선으로 설계**:
    - **성능 최적화**와 **불필요한 데이터 조회 방지**를 위해 지연 로딩을 기본으로 사용하고, 필요한 경우에만 즉시 로딩을 신중하게 적용하는 것이 좋다.